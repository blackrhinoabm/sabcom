import numpy as np
import random
import geopy.distance


class Runner:
    def __init__(self):
        self.identifier = 1

    def baseline(self, environment, seed, verbose=False, high_performance=False):
        # set monte carlo seed
        np.random.seed(seed)
        random.seed(seed)

        # define sets for all agent types
        dead = []
        recovered = []
        critical = []
        sick_with_symptoms = []
        sick_without_symptoms = []
        susceptible = [agent for agent in environment.agents]

        # infect init agents
        init_agents_infected = int(
            environment.parameters["share_inital_agents_infected"] * environment.parameters["number_of_agents"])
        for p in range(init_agents_infected):
            agent_index = np.random.randint(0, len(environment.agents))
            environment.agents[agent_index].status = 'i1'
            sick_without_symptoms.append(environment.agents[agent_index])
        health_overburdened_multiplier = 1

        for t in range(environment.parameters["time"]):
            # create empty list of travel edges
            travel_edges = []

            for agent in susceptible + sick_without_symptoms + sick_with_symptoms + critical:
                # an agent might travel if it is not in critical state
                if np.random.random() < agent.prob_travel and agent.status != 'c':
                    # they sample all agents
                    agents_to_travel_to = random.sample(
                        environment.agents, int(environment.parameters["travel_sample_size"] * len(environment.agents)))
                    # and include travel time to each of these
                    agents_to_travel_to = {a2.name: geopy.distance.geodesic(
                        agent.coordinates, a2.coordinates).km for a2 in agents_to_travel_to if geopy.distance.geodesic(
                        agent.coordinates, a2.coordinates).km > 0.0}
                    # consider there are no viable options to travel to
                    if agents_to_travel_to:
                        # select the agent with shortest travel time
                        location_closest_agent = min(agents_to_travel_to, key=agents_to_travel_to.get)

                        # create edge to that agent
                        edge = (agent.name, location_closest_agent)  # own network location to other network location

                        # and store that edge
                        travel_edges.append(edge)

                # next assign the sickness status to the agents
                if agent.status == 'i1':
                    agent.incubation_days += 1
                    # some agents get symptoms
                    if agent.incubation_days > environment.parameters["incubation_days"]:
                        agent.status = 'i2'
                        sick_without_symptoms.remove(agent)
                        sick_with_symptoms.append(agent)

                elif agent.status == 'i2':
                    agent.sick_days += 1
                    # some agents recover
                    if agent.sick_days > environment.parameters["symptom_days"]:
                        if np.random.random() < agent.prob_hospital:
                            agent.status = 'c'
                            sick_with_symptoms.remove(agent)
                            critical.append(agent)
                        else:
                            agent.status = 'r'
                            sick_with_symptoms.remove(agent)
                            recovered.append(agent)

                elif agent.status == 'c':
                    agent.critical_days += 1
                    # some agents in critical status will die, the rest will recover
                    if agent.critical_days > environment.parameters["critical_days"]:
                        if np.random.random() < (agent.prob_death * health_overburdened_multiplier):
                            agent.status = 'd'
                            critical.remove(agent)
                            dead.append(agent)
                        else:
                            agent.status = 'r'
                            critical.remove(agent)
                            recovered.append(agent)

                elif agent.status == 'r':
                    agent.days_recovered += 1
                    if np.random.random() < (agent.prob_susceptible * agent.days_recovered):
                        recovered.remove(agent)
                        agent.status = 's'
                        susceptible.append(agent)

            # if the health system is overburdened the multiplier for the death rate is higher than otherwise
            if len(critical) / len(environment.agents) > environment.parameters["health_system_capacity"]:
                health_overburdened_multiplier = environment.parameters["no_hospital_multiplier"]
            else:
                health_overburdened_multiplier = 1.0

            # create travel edges
            environment.network.add_edges_from(travel_edges)

            for agent in sick_without_symptoms + sick_with_symptoms:
                # set the number of other agents infected this period 0
                agent.others_infected = 0
                # find indices from neighbour agents
                neighbours_from_graph = [x for x in environment.network.neighbors(agent.name)]
                # find the corresponding agents
                neighbours_to_infect = [environment.agents[idx] for idx in neighbours_from_graph]
                # let these agents be infected (with random probability
                for neighbour in neighbours_to_infect:
                    if neighbour.status == 's' and np.random.random() < agent.prob_transmission:
                        neighbour.status = 'i1'
                        susceptible.remove(neighbour)
                        sick_without_symptoms.append(neighbour)
                        agent.others_infected += 1

            if high_performance:
                print(t)
                # self.infection_states.append({'s1':len(sick_without_symptoms), 's2': len(sick_with_symptoms),
                #             'c': len(critical), 'd': len(dead), 'r': len(recovered)})
            else:
                environment.infection_states.append(environment.store_network())
                environment.write_status_location(t, seed, "measurement/baseline/")

            # delete travel edges
            environment.network.remove_edges_from(travel_edges)

            if verbose:
                print('time = ', t)
                print(environment.network.nodes)

    def calculate_R0(self, environment, seed, idx_patient_zero):
        # set monte carlo seed
        np.random.seed(seed)
        random.seed(seed)

        # define sets for all agent types
        dead = []
        recovered = []
        critical = []
        sick_with_symptoms = []
        sick_without_symptoms = []
        susceptible = [agent for agent in environment.agents]

        # infect patient zero
        environment.agents[idx_patient_zero].status = 'i1'
        sick_without_symptoms.append(environment.agents[idx_patient_zero])
        health_overburdened_multiplier = 1

        for t in range(environment.parameters["time"]):
            # create empty list of travel edges
            travel_edges = []

            for agent in susceptible + sick_without_symptoms + sick_with_symptoms + critical:
                # an agent might travel if it is not in critical state
                if np.random.random() < agent.prob_travel and agent.status != 'c':
                    # they sample all agents
                    agents_to_travel_to = random.sample(
                        environment.agents, int(environment.parameters["travel_sample_size"] * len(environment.agents)))
                    # and include travel time to each of these
                    agents_to_travel_to = {a2.name: geopy.distance.geodesic(
                        agent.coordinates, a2.coordinates).km for a2 in agents_to_travel_to if geopy.distance.geodesic(
                        agent.coordinates, a2.coordinates).km > 0.0}
                    # consider there are no viable options to travel to
                    if agents_to_travel_to:
                        # select the agent with shortest travel time
                        location_closest_agent = min(agents_to_travel_to, key=agents_to_travel_to.get)

                        # create edge to that agent
                        edge = (agent.name, location_closest_agent)  # own network location to other network location

                        # and store that edge
                        travel_edges.append(edge)

                # next assign the sickness status to the agents
                if agent.status == 'i1':
                    agent.incubation_days += 1
                    # some agents get symptoms
                    if agent.incubation_days > environment.parameters["incubation_days"]:
                        agent.status = 'i2'
                        sick_without_symptoms.remove(agent)
                        sick_with_symptoms.append(agent)

                elif agent.status == 'i2':
                    agent.sick_days += 1
                    # some agents recover
                    if agent.sick_days > environment.parameters["symptom_days"]:
                        if np.random.random() < agent.prob_hospital:
                            agent.status = 'c'
                            sick_with_symptoms.remove(agent)
                            critical.append(agent)
                        else:
                            if agent == environment.agents[idx_patient_zero]:
                                print('patient zero recovered or dead')
                                return agent.others_infected

                            agent.status = 'r'
                            sick_with_symptoms.remove(agent)
                            recovered.append(agent)

                elif agent.status == 'c':
                    agent.critical_days += 1
                    # some agents in critical status will die, the rest will recover
                    if agent.critical_days > environment.parameters["critical_days"]:
                        if agent == environment.agents[idx_patient_zero]:
                            print('patient zero recovered or dead')
                            return agent.others_infected
                        if np.random.random() < (agent.prob_death * health_overburdened_multiplier):
                            agent.status = 'd'
                            critical.remove(agent)
                            dead.append(agent)
                        else:
                            agent.status = 'r'
                            critical.remove(agent)
                            recovered.append(agent)

                elif agent.status == 'r':
                    agent.days_recovered += 1
                    if np.random.random() < (agent.prob_susceptible * agent.days_recovered):
                        recovered.remove(agent)
                        agent.status = 's'
                        susceptible.append(agent)

            # if the health system is overburdened the multiplier for the death rate is higher than otherwise
            if len(critical) / len(environment.agents) > environment.parameters["health_system_capacity"]:
                health_overburdened_multiplier = environment.parameters["no_hospital_multiplier"]
            else:
                health_overburdened_multiplier = 1.0

            # create travel edges
            environment.network.add_edges_from(travel_edges)

            for agent in sick_without_symptoms + sick_with_symptoms:
                # find indices from neighbour agents
                neighbours_from_graph = [x for x in environment.network.neighbors(agent.name)]
                # find the corresponding agents
                neighbours_to_infect = [environment.agents[idx] for idx in neighbours_from_graph]
                # let these agents be infected (with random probability
                for neighbour in neighbours_to_infect:
                    if neighbour.status == 's' and np.random.random() < agent.prob_transmission:
                        neighbour.status = 'i1'
                        susceptible.remove(neighbour)
                        sick_without_symptoms.append(neighbour)
                        agent.others_infected += 1

            # delete travel edges
            environment.network.remove_edges_from(travel_edges)

    def lock_down(self, environment, seed, verbose=False, high_performance=False):
        """In this simulation there is a lockdown for a certain period"""
        # set monte carlo seed
        np.random.seed(seed)
        random.seed(seed)

        # define sets for all agent types
        dead = []
        recovered = []
        critical = []
        sick_with_symptoms = []
        sick_without_symptoms = []
        susceptible = [agent for agent in environment.agents]

        # infect init agents
        init_agents_infected = int(
            environment.parameters["share_inital_agents_infected"] * environment.parameters["number_of_agents"])
        for p in range(init_agents_infected):
            agent_index = np.random.randint(0, len(environment.agents))
            environment.agents[agent_index].status = 'i1'
            sick_without_symptoms.append(environment.agents[agent_index])
        health_overburdened_multiplier = 1

        for t in range(environment.parameters["time"]):
            # the lockdown influence the travel multiplier and infection multiplier (probability to infect)
            if t in environment.parameters["lockdown_days"]:
                lockdown = True
            else:
                lockdown = False

            if lockdown:
                # reduce probability of infecting others by ...
                lockdown_infection_multiplier = environment.parameters["lockdown_infection_multiplier"]
                # reduce travel proability by ..
                lockdown_travel_multiplier = environment.parameters["lockdown_travel_multiplier"]
            else:
                lockdown_infection_multiplier = 1.0
                lockdown_travel_multiplier = 1.0

            # create empty list of travel edges
            travel_edges = []

            for agent in susceptible + sick_without_symptoms + sick_with_symptoms + critical:
                # an agent might travel if it is not in critical state
                if np.random.random() < (agent.prob_travel * lockdown_travel_multiplier) and agent.status != 'c':
                    # they sample all agents
                    agents_to_travel_to = random.sample(
                        environment.agents, int(environment.parameters["travel_sample_size"] * len(environment.agents)))
                    # and include travel time to each of these
                    agents_to_travel_to = {a2.name: geopy.distance.geodesic(
                        agent.coordinates, a2.coordinates).km for a2 in agents_to_travel_to if geopy.distance.geodesic(
                        agent.coordinates, a2.coordinates).km > 0.0}
                    # consider there are no viable options to travel to
                    if agents_to_travel_to:
                        # select the agent with shortest travel time
                        location_closest_agent = min(agents_to_travel_to, key=agents_to_travel_to.get)

                        # create edge to that agent
                        edge = (agent.name, location_closest_agent)  # own network location to other network location

                        # and store that edge
                        travel_edges.append(edge)

                # next assign the sickness status to the agents
                if agent.status == 'i1':
                    agent.incubation_days += 1
                    # some agents get symptoms
                    if agent.incubation_days > environment.parameters["incubation_days"]:
                        agent.status = 'i2'
                        sick_without_symptoms.remove(agent)
                        sick_with_symptoms.append(agent)

                elif agent.status == 'i2':
                    agent.sick_days += 1
                    # some agents recover
                    if agent.sick_days > environment.parameters["symptom_days"]:
                        if np.random.random() < agent.prob_hospital:
                            agent.status = 'c'
                            sick_with_symptoms.remove(agent)
                            critical.append(agent)
                        else:
                            agent.status = 'r'
                            sick_with_symptoms.remove(agent)
                            recovered.append(agent)

                elif agent.status == 'c':
                    agent.critical_days += 1
                    # some agents in critical status will die, the rest will recover
                    if agent.critical_days > environment.parameters["critical_days"]:
                        if np.random.random() < (agent.prob_death * health_overburdened_multiplier):
                            agent.status = 'd'
                            critical.remove(agent)
                            dead.append(agent)
                        else:
                            agent.status = 'r'
                            critical.remove(agent)
                            recovered.append(agent)

                elif agent.status == 'r':
                    agent.days_recovered += 1
                    if np.random.random() < (agent.prob_susceptible * agent.days_recovered):
                        recovered.remove(agent)
                        agent.status = 's'
                        susceptible.append(agent)

            # if the health system is overburdened the multiplier for the death rate is higher than otherwise
            if len(critical) / len(environment.agents) > environment.parameters["health_system_capacity"]:
                health_overburdened_multiplier = environment.parameters["no_hospital_multiplier"]
            else:
                health_overburdened_multiplier = 1.0

            # create travel edges
            environment.network.add_edges_from(travel_edges)

            for agent in sick_without_symptoms + sick_with_symptoms:
                # set the number of other agents infected this period 0
                agent.others_infected = 0
                # find indices from neighbour agents
                neighbours_from_graph = [x for x in environment.network.neighbors(agent.name)]
                # find the corresponding agents
                neighbours_to_infect = [environment.agents[idx] for idx in neighbours_from_graph]
                # let these agents be infected (with random probability
                for neighbour in neighbours_to_infect:
                    if neighbour.status == 's' and np.random.random() < (agent.prob_transmission * lockdown_infection_multiplier):
                        neighbour.status = 'i1'
                        susceptible.remove(neighbour)
                        sick_without_symptoms.append(neighbour)
                        agent.others_infected += 1

            if high_performance:
                print(t)
                # self.infection_states.append({'s1':len(sick_without_symptoms), 's2': len(sick_with_symptoms),
                #             'c': len(critical), 'd': len(dead), 'r': len(recovered)})
            else:
                environment.infection_states.append(environment.store_network())
                environment.write_status_location(t, seed, "measurement/lockdown/")

            # delete travel edges
            environment.network.remove_edges_from(travel_edges)

            if verbose:
                print('time = ', t)
                print(environment.network.nodes)

    def ineffective_lock_down(self, environment, seed, verbose=False, high_performance=False):
        """In this simulation the lock-down is not effective in informal settlements"""
        # set monte carlo seed
        np.random.seed(seed)
        random.seed(seed)

        # define sets for all agent types
        dead = []
        recovered = []
        critical = []
        sick_with_symptoms = []
        sick_without_symptoms = []
        susceptible = [agent for agent in environment.agents]

        # infect init agents
        init_agents_infected = int(
            environment.parameters["share_inital_agents_infected"] * environment.parameters["number_of_agents"])
        for p in range(init_agents_infected):
            agent_index = np.random.randint(0, len(environment.agents))
            environment.agents[agent_index].status = 'i1'
            sick_without_symptoms.append(environment.agents[agent_index])
        health_overburdened_multiplier = 1

        for t in range(environment.parameters["time"]):
            # the lockdown influence the travel multiplier and infection multiplier (probability to infect)
            if t in environment.parameters["lockdown_days"]:
                lockdown = True
            else:
                lockdown = False

            if lockdown:
                # reduce probability of infecting others by ...
                lockdown_infection_multiplier = environment.parameters["lockdown_infection_multiplier"]
                # reduce travel proability by ..
                lockdown_travel_multiplier = environment.parameters["lockdown_travel_multiplier"]
            else:
                lockdown_infection_multiplier = 1.0
                lockdown_travel_multiplier = 1.0

            # create empty list of travel edges
            travel_edges = []

            for agent in susceptible + sick_without_symptoms + sick_with_symptoms + critical:
                # an agent might travel if it is not in critical state
                if np.random.random() < (agent.prob_travel * (
                        lockdown_travel_multiplier + (1 - lockdown_travel_multiplier) * agent.informality)) and agent.status != 'c':
                    # they sample all agents
                    agents_to_travel_to = random.sample(
                        environment.agents, int(environment.parameters["travel_sample_size"] * len(environment.agents)))
                    # and include travel time to each of these
                    agents_to_travel_to = {a2.name: geopy.distance.geodesic(
                        agent.coordinates, a2.coordinates).km for a2 in agents_to_travel_to if geopy.distance.geodesic(
                        agent.coordinates, a2.coordinates).km > 0.0}
                    # consider there are no viable options to travel to
                    if agents_to_travel_to:
                        # select the agent with shortest travel time
                        location_closest_agent = min(agents_to_travel_to, key=agents_to_travel_to.get)

                        # create edge to that agent
                        edge = (agent.name, location_closest_agent)  # own network location to other network location

                        # and store that edge
                        travel_edges.append(edge)

                # next assign the sickness status to the agents
                if agent.status == 'i1':
                    agent.incubation_days += 1
                    # some agents get symptoms
                    if agent.incubation_days > environment.parameters["incubation_days"]:
                        agent.status = 'i2'
                        sick_without_symptoms.remove(agent)
                        sick_with_symptoms.append(agent)

                elif agent.status == 'i2':
                    agent.sick_days += 1
                    # some agents recover
                    if agent.sick_days > environment.parameters["symptom_days"]:
                        if np.random.random() < agent.prob_hospital:
                            agent.status = 'c'
                            sick_with_symptoms.remove(agent)
                            critical.append(agent)
                        else:
                            agent.status = 'r'
                            sick_with_symptoms.remove(agent)
                            recovered.append(agent)

                elif agent.status == 'c':
                    agent.critical_days += 1
                    # some agents in critical status will die, the rest will recover
                    if agent.critical_days > environment.parameters["critical_days"]:
                        if np.random.random() < (agent.prob_death * health_overburdened_multiplier):
                            agent.status = 'd'
                            critical.remove(agent)
                            dead.append(agent)
                        else:
                            agent.status = 'r'
                            critical.remove(agent)
                            recovered.append(agent)

                elif agent.status == 'r':
                    agent.days_recovered += 1
                    if np.random.random() < (agent.prob_susceptible * agent.days_recovered):
                        recovered.remove(agent)
                        agent.status = 's'
                        susceptible.append(agent)

            # if the health system is overburdened the multiplier for the death rate is higher than otherwise
            if len(critical) / len(environment.agents) > environment.parameters["health_system_capacity"]:
                health_overburdened_multiplier = environment.parameters["no_hospital_multiplier"]
            else:
                health_overburdened_multiplier = 1.0

            # create travel edges
            environment.network.add_edges_from(travel_edges)

            for agent in sick_without_symptoms + sick_with_symptoms:
                # set the number of other agents infected this period 0
                agent.others_infected = 0
                # find indices from neighbour agents
                neighbours_from_graph = [x for x in environment.network.neighbors(agent.name)]
                # find the corresponding agents
                neighbours_to_infect = [environment.agents[idx] for idx in neighbours_from_graph]
                # let these agents be infected (with random probability
                for neighbour in neighbours_to_infect:
                    if neighbour.status == 's' and np.random.random() < (
                            agent.prob_transmission * (
                            lockdown_infection_multiplier + (1 - lockdown_infection_multiplier) * agent.informality)):
                        neighbour.status = 'i1'
                        susceptible.remove(neighbour)
                        sick_without_symptoms.append(neighbour)
                        agent.others_infected += 1

            if high_performance:
                print(t)
                # self.infection_states.append({'s1':len(sick_without_symptoms), 's2': len(sick_with_symptoms),
                #             'c': len(critical), 'd': len(dead), 'r': len(recovered)})
            else:
                environment.infection_states.append(environment.store_network())
                environment.write_status_location(t, seed, "measurement/inef_lockdown/")

            # delete travel edges
            environment.network.remove_edges_from(travel_edges)

            if verbose:
                print('time = ', t)
                print(environment.network.nodes)

    def elderly_inef_lock_down(self, environment, seed, verbose=False, high_performance=False):
        """In this simulation the lock-down applies only to risk groups and is not effective in informal settlements"""
        # set monte carlo seed
        np.random.seed(seed)
        random.seed(seed)

        # define sets for all agent types
        dead = []
        recovered = []
        critical = []
        sick_with_symptoms = []
        sick_without_symptoms = []
        susceptible = [agent for agent in environment.agents]

        # infect init agents
        init_agents_infected = int(
            environment.parameters["share_inital_agents_infected"] * environment.parameters["number_of_agents"])
        for p in range(init_agents_infected):
            agent_index = np.random.randint(0, len(environment.agents))
            environment.agents[agent_index].status = 'i1'
            sick_without_symptoms.append(environment.agents[agent_index])
        health_overburdened_multiplier = 1

        for t in range(environment.parameters["time"]):
            # the lockdown influence the travel multiplier and infection multiplier (probability to infect)
            if t in environment.parameters["lockdown_days"]:
                # reduce probability of infecting others by ...
                lockdown_infection_multiplier = environment.parameters["lockdown_infection_multiplier"]
                # reduce travel proability by ..
                lockdown_travel_multiplier = environment.parameters["lockdown_travel_multiplier"]
            else:
                lockdown_infection_multiplier = 1.0
                lockdown_travel_multiplier = 1.0

            # create empty list of travel edges
            travel_edges = []

            for agent in susceptible + sick_without_symptoms + sick_with_symptoms + critical:
                # determine if the agent is at risk
                if agent.age_group not in environment.parameters["high_risk_groups"]:
                    young_dummy = 1.0
                else:
                    young_dummy = 0.0

                informality_term = (1 - lockdown_travel_multiplier) * agent.informality
                elderly_term = 1 - lockdown_travel_multiplier - informality_term
                # an agent might travel if it is not in critical state
                if np.random.random() < (agent.prob_travel * (
                        lockdown_travel_multiplier + informality_term + (elderly_term * young_dummy))) and agent.status != 'c':
                    # they sample all agents
                    agents_to_travel_to = random.sample(
                        environment.agents, int(environment.parameters["travel_sample_size"] * len(environment.agents)))
                    # and include travel time to each of these
                    agents_to_travel_to = {a2.name: geopy.distance.geodesic(
                        agent.coordinates, a2.coordinates).km for a2 in agents_to_travel_to if geopy.distance.geodesic(
                        agent.coordinates, a2.coordinates).km > 0.0}
                    # consider there are no viable options to travel to
                    if agents_to_travel_to:
                        # select the agent with shortest travel time
                        location_closest_agent = min(agents_to_travel_to, key=agents_to_travel_to.get)

                        # create edge to that agent
                        edge = (agent.name, location_closest_agent)  # own network location to other network location

                        # and store that edge
                        travel_edges.append(edge)

                # next assign the sickness status to the agents
                if agent.status == 'i1':
                    agent.incubation_days += 1
                    # some agents get symptoms
                    if agent.incubation_days > environment.parameters["incubation_days"]:
                        agent.status = 'i2'
                        sick_without_symptoms.remove(agent)
                        sick_with_symptoms.append(agent)

                elif agent.status == 'i2':
                    agent.sick_days += 1
                    # some agents recover
                    if agent.sick_days > environment.parameters["symptom_days"]:
                        if np.random.random() < agent.prob_hospital:
                            agent.status = 'c'
                            sick_with_symptoms.remove(agent)
                            critical.append(agent)
                        else:
                            agent.status = 'r'
                            sick_with_symptoms.remove(agent)
                            recovered.append(agent)

                elif agent.status == 'c':
                    agent.critical_days += 1
                    # some agents in critical status will die, the rest will recover
                    if agent.critical_days > environment.parameters["critical_days"]:
                        if np.random.random() < (agent.prob_death * health_overburdened_multiplier):
                            agent.status = 'd'
                            critical.remove(agent)
                            dead.append(agent)
                        else:
                            agent.status = 'r'
                            critical.remove(agent)
                            recovered.append(agent)

                elif agent.status == 'r':
                    agent.days_recovered += 1
                    if np.random.random() < (agent.prob_susceptible * agent.days_recovered):
                        recovered.remove(agent)
                        agent.status = 's'
                        susceptible.append(agent)

            # if the health system is overburdened the multiplier for the death rate is higher than otherwise
            if len(critical) / len(environment.agents) > environment.parameters["health_system_capacity"]:
                health_overburdened_multiplier = environment.parameters["no_hospital_multiplier"]
            else:
                health_overburdened_multiplier = 1.0

            # create travel edges
            environment.network.add_edges_from(travel_edges)

            for agent in sick_without_symptoms + sick_with_symptoms:
                # set the number of other agents infected this period 0
                agent.others_infected = 0
                # find indices from neighbour agents
                neighbours_from_graph = [x for x in environment.network.neighbors(agent.name)]
                # find the corresponding agents
                neighbours_to_infect = [environment.agents[idx] for idx in neighbours_from_graph]
                # let these agents be infected (with random probability
                for neighbour in neighbours_to_infect:
                    if neighbour.age_group not in environment.parameters["high_risk_groups"]:
                        young_dummy = 1.0
                    else:
                        young_dummy = 0.0

                    informality_term = (1 - lockdown_infection_multiplier) * agent.informality
                    elderly_term = 1 - lockdown_infection_multiplier - informality_term

                    if neighbour.status == 's' and np.random.random() < (
                            agent.prob_transmission * (
                            lockdown_travel_multiplier + informality_term + (elderly_term * young_dummy))):
                        neighbour.status = 'i1'
                        susceptible.remove(neighbour)
                        sick_without_symptoms.append(neighbour)
                        agent.others_infected += 1

            if high_performance:
                print(t)
                # self.infection_states.append({'s1':len(sick_without_symptoms), 's2': len(sick_with_symptoms),
                #             'c': len(critical), 'd': len(dead), 'r': len(recovered)})
            else:
                environment.infection_states.append(environment.store_network())
                environment.write_status_location(t, seed, "measurement/lock_down_elderly/")

            # delete travel edges
            environment.network.remove_edges_from(travel_edges)

            if verbose:
                print('time = ', t)
                print(environment.network.nodes)


    def baseline_value(self, value, environment, seed, verbose=False, high_performance=False):
    # set monte carlo seed
        np.random.seed(seed)
        random.seed(seed)

        # define sets for all agent types
        dead = []
        recovered = []
        critical = []
        sick_with_symptoms = []
        sick_without_symptoms = []
        susceptible = [agent for agent in environment.agents]

        # infect init agents
        init_agents_infected = int(
            environment.parameters["share_inital_agents_infected"] * environment.parameters["number_of_agents"])
        for p in range(init_agents_infected):
            agent_index = np.random.randint(0, len(environment.agents))
            environment.agents[agent_index].status = 'i1'
            sick_without_symptoms.append(environment.agents[agent_index])
        health_overburdened_multiplier = 1

        for t in range(environment.parameters["time"]):
            # create empty list of travel edges
            travel_edges = []

            for agent in susceptible + sick_without_symptoms + sick_with_symptoms + critical:
                # an agent might travel if it is not in critical state
                if np.random.random() < agent.prob_travel and agent.status != 'c':
                    # they sample all agents
                    agents_to_travel_to = random.sample(
                        environment.agents, int(environment.parameters["travel_sample_size"] * len(environment.agents)))
                    # and include travel time to each of these
                    agents_to_travel_to = {a2.name: geopy.distance.geodesic(
                        agent.coordinates, a2.coordinates).km for a2 in agents_to_travel_to if geopy.distance.geodesic(
                        agent.coordinates, a2.coordinates).km > 0.0}
                    # consider there are no viable options to travel to
                    if agents_to_travel_to:
                        # select the agent with shortest travel time
                        location_closest_agent = min(agents_to_travel_to, key=agents_to_travel_to.get)

                        # create edge to that agent
                        edge = (agent.name, location_closest_agent)  # own network location to other network location

                        # and store that edge
                        travel_edges.append(edge)

                # next assign the sickness status to the agents
                if agent.status == 'i1':
                    agent.incubation_days += 1
                    # some agents get symptoms
                    if agent.incubation_days > environment.parameters["incubation_days"]:
                        agent.status = 'i2'
                        sick_without_symptoms.remove(agent)
                        sick_with_symptoms.append(agent)

                elif agent.status == 'i2':
                    agent.sick_days += 1
                    # some agents recover
                    if agent.sick_days > environment.parameters["symptom_days"]:
                        if np.random.random() < agent.prob_hospital:
                            agent.status = 'c'
                            sick_with_symptoms.remove(agent)
                            critical.append(agent)
                        else:
                            agent.status = 'r'
                            sick_with_symptoms.remove(agent)
                            recovered.append(agent)

                elif agent.status == 'c':
                    agent.critical_days += 1
                    # some agents in critical status will die, the rest will recover
                    if agent.critical_days > environment.parameters["critical_days"]:
                        if np.random.random() < (agent.prob_death * health_overburdened_multiplier):
                            agent.status = 'd'
                            critical.remove(agent)
                            dead.append(agent)
                        else:
                            agent.status = 'r'
                            critical.remove(agent)
                            recovered.append(agent)

                elif agent.status == 'r':
                    agent.days_recovered += 1
                    if np.random.random() < (agent.prob_susceptible * agent.days_recovered):
                        recovered.remove(agent)
                        agent.status = 's'
                        susceptible.append(agent)

            # if the health system is overburdened the multiplier for the death rate is higher than otherwise
            if len(critical) / len(environment.agents) > environment.parameters["health_system_capacity"]:
                health_overburdened_multiplier = environment.parameters["no_hospital_multiplier"]
            else:
                health_overburdened_multiplier = 1.0

            # create travel edges
            environment.network.add_edges_from(travel_edges)

            for agent in sick_without_symptoms + sick_with_symptoms:
                # set the number of other agents infected this period 0
                agent.others_infected = 0
                # find indices from neighbour agents
                neighbours_from_graph = [x for x in environment.network.neighbors(agent.name)]
                # find the corresponding agents
                neighbours_to_infect = [environment.agents[idx] for idx in neighbours_from_graph]
                # let these agents be infected (with random probability
                for neighbour in neighbours_to_infect:
                    if neighbour.status == 's' and np.random.random() < agent.prob_transmission:
                        neighbour.status = 'i1'
                        susceptible.remove(neighbour)
                        sick_without_symptoms.append(neighbour)
                        agent.others_infected += 1

            if high_performance:
                print(t)
                # self.infection_states.append({'s1':len(sick_without_symptoms), 's2': len(sick_with_symptoms),
                #             'c': len(critical), 'd': len(dead), 'r': len(recovered)})
            else:
                environment.infection_states.append(environment.store_network())
                environment.write_status_location(t, seed, "measurement/baseline/"+str(value)+'/')

            # delete travel edges
            environment.network.remove_edges_from(travel_edges)

            if verbose:
                print('time = ', t)
                print(environment.network.nodes)

